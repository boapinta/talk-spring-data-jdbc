= Spring Data JDBC
:icons: font
:twitter-tag: @jensschauder
:conference-tag:
:talk-tag: #sd-jdbc
:slide-link: http://bit.ly/talk-sd-jdbc
:linkattrs:
:main-incl: {src-incl}/src/main/java/de/schauderhaft/spring/data/jdbc/talk/
:test-incl: {src-incl}/src/test/java/de/schauderhaft/spring/data/jdbc/talk/
:res-incl: {src-incl}/src/main/resources/

include::footer.ad[]

{nbsp} +
{nbsp} +

[small]#Press S for speaker notes#

== Talk Motto

image::shame.png[canvas,size=contain]

[quote, "Reid Hoffman"]
____
If you are not embarrassed by the first version of your product, youâ€™ve launched too late.
____

=== Default Answer

* No that feature doesn't exist yet.

* We accept pull requests.

[NOTE.speaker]
====
I'll do my work, but it will take time.
====

== Spring Data

image::spring-data.png[canvas,size=contain]

[NOTE.speaker]
====
* Consistent Programming Model for data access.

* Inspired by DDD

* Modules for JPA, Mongo, Cassandra, Neo4j ...

* Repository Abstraction
====

== JPA vs Spring Data Jdbc

image::jpa-sdjdbc.png[canvas,size=contain]

=== JPAs complexity

[NOTE.speaker]
====
JPAs enormous power comes with considerable complexity
====

=== Lazy Loading (Exception)

=== Dirty Checking

[NOTE.speaker]
====
What if you change an entity but don't want to save it?
====

=== Session / 1st Level Cache

[NOTE.speaker]
====
You can't for example load the unchanged entity in an event
====

=== Proxies for Entities

=== Map almost anything to anything

== Spring Data JDBCs Design Choices

image::compass.png[canvas,size=contain]

=== No Lazy Loading

=== No Caching

=== No Proxies

=== No deferred flushing

=== Very simple & limited & opinionated ORM

=== Simplicity is King

Complexity is tempting

== Consider Spring Data JDBC

image::meter.png[canvas,size=contain]

if you ...

=== want to custom code most SQL anyway

=== find yourself fighting JPA

=== want to have DDD Aggregates

(but still want to use a RDBMS)

== CrudRepository

=== Dependencies

[source, xml, indent=0, tabsize=2]
----
include::{src-incl}pom.xml[tags=sdjdbc]
----

=== The usual suspects

* hsqldb
* lombok
* junit
* spring-test
* assertj

[NOTE.speaker]
====
These are just my choices,
of course you can pick what ever you want.
====

=== Configuration

=== !

[source, java, indent=0, tabsize=2]
----
include::{main-incl}SpringleticsConfiguration.java[tags=datasource]
----

=== Configuration (Template)

[source, java, indent=0, tabsize=2]
----
include::{main-incl}SpringleticsConfiguration.java[tags=template]
----

[NOTE.speaker]
====
You just need a `NamedParameterjdbcTemplate` but we'll need the separate `DataSource` later on.

`@EnableJdbcRepositories` finds and create repository interfaces
====

=== Entity

[source, java, indent=0, tabsize=2]
----
include::{main-incl}Workout.java[tags=main]
----

=== Entity

All you need is an `@Id`

* getters/setters are optional

* default constructor is optional

=== Repository

[source, java, indent=0, tabsize=2]
----
include::{main-incl}WorkoutRepository.java[tags=main]
----

[NOTE.speaker]
====
You just declare a with type parameters interface, the repository gets generated by Spring Data Jdbc on the fly.
====

=== Schema

[source, sql, indent=0, tabsize=2]
----
include::{res-incl}create-schema.sql[]
----

[NOTE.speaker]
====
Currently there is no DDL creation feature.
While probably necessary in the long run we might make it separate from the main module in order to avoid people using it in production.
====


=== Create, Read

[source, java, indent=0, tabsize=2]
----
include::{test-incl}SpringleticsTest.java[tags=create]
----

=== Update, Delete

[source, java, indent=0, tabsize=2]
----
include::{test-incl}SpringleticsTest.java[tags=update]
----

=== Log Output

[source,sql]
----
INSERT INTO Workout (name, focus) VALUES (?, ?)
SELECT Workout.id AS id, Workout.name AS name, Workout.focus AS focus
       FROM Workout WHERE Workout.id = ?
UPDATE Workout set id = ?, name = ?, focus = ? where id = ?
DELETE FROM Workout where id = ?
----

[NOTE.speaker]
====
All statements get executed during the matching method call.
No caching or anything.
====

=== CrudRepository Save Methods

[source, java]
----
<S extends T> S           save(S entity);
<S extends T> Iterable<S> saveAll(
                    Iterable<S> entities);
----

=== CrudRepository Read Methods

[source, java]
----
Optional<T> findById(ID id);
boolean     existsById(ID id);
Iterable<T> findAll();
Iterable<T> findAllById(Iterable<ID> ids);
long        count();
----

=== CrudRepository Delete Methods

[source, java]
----
void        deleteById(ID id);
void        delete(T entity);
void        deleteAll(Iterable<? extends T>
                    entities);
void        deleteAll();
----

== NamingStrategy

image::name.png[canvas,size=contain]

=== !

[source, java]
----
public interface NamingStrategy {
    String getSchema();
    String getTableName(Class<?> type);
    String getQualifiedTableName(Class<?> type);
    
    String getColumnName(
        JdbcPersistentProperty property);
    String getReverseColumnName(
        JdbcPersistentProperty property);
    String getKeyColumn(
        JdbcPersistentProperty property);
}
----


== Non trivial Aggregates

image::aggregate.png[canvas,size=contain]

=== Design Challenge

CRUD Operations for entities with references

aka ORM

[NOTE.speaker]
====
You probably want to save an `Order` with it's `items` in one go.

But

* We don't want to rebuild Hibernate.

* We want to keep things simple.

* Yet have something useful.

I killed about a month just for this one.

I hated it at first.

But by now I think it's actually quite nice.
====

=== Springletics Workout

[source,java]
----
class Workout {
    // ...
    List<Exercise> exercises
    // ...
}
----

[NOTE.speaker]
====
Let's look at an example.

A workout consists of multiple Exercises.
Think pushups or squats.
====

=== Pseudo Code

[source,pseudo]
----
wo = createWorkout();
wo = repository.save(wo);
wo = changeWorkout(wo);
repository.save(wo);
----

[NOTE.speaker]
====
create, save

change, save again

Question: How should the statements look like?
====

=== SQL Statments

[source,sql]
----
// first save
INSERT INTO Workout (name, focus) VALUES (?, ?)
INSERT INTO Exercise (name, description, Workout, Workout_key) VALUES (?, ?, ?, ?)

// second save
DELETE FROM Exercise WHERE Workout = ?
UPDATE Workout set id = ?, name = ?, focus = ? WHERE id = ?
INSERT INTO Exercise (name, description, Workout, Workout_key) VALUES (?, ?, ?, ?)
----

=== WAT?

* **DELETE ALL referenced Entities!**

* UPDATE Aggregate Root

* REINSERT ALL referenced Entities

=== What will improve

* DELETE ALL formerly referenced Entities

* UPDATE Aggregate Root

* UPDATE still referenced Entities

* INSERT new Entities

== => No Many-to-X relations!

image::seagull.png[canvas,size=contain]

[NOTE.speaker]
====
You can't have Many to anything relationships.

One to one and one to many are fine though.

Don't run away, there are reasons for this.
====

=== Repositories work on Aggregates

[quote, "Martin Fowler", https://martinfowler.com/bliki/DDD_Aggregate.html]
____
Aggregates are the basic element of transfer of data storage - you request to load or save whole aggregates.
____

[NOTE.speaker]
====
When ever you load or save something, you are dealing with complete aggregates.
====

=== Aggregate

[quote, "Martin Fowler", https://martinfowler.com/bliki/DDD_Aggregate.html]
____

Aggregate is a pattern in Domain-Driven Design.
A DDD aggregate is a cluster of domain objects that can be treated as a single unit.
____

[NOTE.speaker]
====
An entity is either part of one or the other aggregate, but it can never be part of the two aggregates.
====

=== Aggregate Root

[quote, "Martin Fowler", https://martinfowler.com/bliki/DDD_Aggregate.html]
____

An aggregate will have one of its component objects be the aggregate root.
Any references from outside the aggregate should only go to the aggregate root.
The root can thus ensure the integrity of the aggregate as a whole.
____

[NOTE.speaker]
====
If from inside of one aggregate you don't touch the stuff of another aggregate.
====

=== Many to X relations

If multiple Aggregate roots reference X,

X must be another Aggregate Root.

=> Not part of this Aggregate.

=== What is part of the Aggregate?

Everything referenced.

=== What to do

* Just reference an id.

[NOTE.speaker]
====
In the database you might consider

* no constraints across aggregates.

* deferred constraints.
====

=== But I don't like that!

* That's ok.

Use

* `@Query`

* Custom method implementations

* Custom base repository

=== Just consider for a moment

* It is a strong constraint

* It might improve your architecture

[NOTE.speaker]
====
* Makes bounds of aggregates really obvious.

* Greatly simplifies things like test setup for integration tests.

* Allows complete change of persistence strategy for one aggregate, while keeping others as they are.
====

== Events

image::event.png[canvas,size=contain]

=== Register a Listener

[source, java, indent=0, tabsize=2]
----
include::{main-incl}BeforeSaveListener.java[tags=main]
----

=== Available Events

* `BeforeSaveEvent`
* `AfterSaveEvent`
* `BeforeDeleteEvent`
* `AfterDeleteEvent`
* `AfterLoadEvent` - when an Aggregate got instantiated from the database

[NOTE.speaker]
====
Beware there are events with the same name in Spring Data Rest
====


=== `AggregateChange`

* A model of the changes to be applied to the database
* contains a **mutable** list of `DbAction` s.

=== `DbAction`

Represents a single SQL statement to be executed against the database.

=== Do whatever you want

* Access the repository
* change the entities
* **Change** the `AggregateChange`!

== MyBatis

image::mybatis.png[canvas,size=contain]

=== How?

=== CRUD methods get translated into DbActions

=== Each action gets mapped to a MyBatis query id.

=== If not found default implementation is used.

Example: Deleting all via a given property path referenced entities -> `deleteAll.<propertyPath>`

=== Dependencies

[source, xml, indent=0, tabsize=2]
----
include::{src-incl}pom.xml[tags=mybatis]
----

=== Context

=== !

[source, java, indent=0, tabsize=2]
----
include::{main-incl}mybatis/WithMyBatisConfiguration.java[tags=mybatis1]
----

=== Context

[source, java, indent=0, tabsize=2]
----
include::{main-incl}mybatis/WithMyBatisConfiguration.java[tags=mybatis2]
----

=== Context

[source, java, indent=0, tabsize=2]
----
include::{main-incl}mybatis/WithMyBatisConfiguration.java[tags=mybatis3]
----

=== Mapping

=== !
[source, xml, indent=0, tabsize=2]
----
include::{src-incl}src/main/resources/de/schauderhaft/spring/data/jdbc/talk/WorkoutMapper.xml[]
----

=== Thanks!

**Kazuki Shimizu**

kazuki43zoo

== `@Query`

image::select.png[canvas,size=contain]

=== `@Query`

[source, java, indent=0, tabsize=2]
----
include::{main-incl}WorkoutRepository.java[tags=query]
----

=== `@Modifying`

[source, java, indent=0, tabsize=2]
----
include::{main-incl}WorkoutRepository.java[tags=modifying]
----

=== RowMapper

[source, java, indent=0, tabsize=2]
----
include::{main-incl}WorkoutRepository.java[tags=rowmapper1]
----

=== RowMapper

[source, java, indent=0, tabsize=2]
----
include::{main-incl}WorkoutRepository.java[tags=rowmapper2]
----

== Integration with SD-Rest

image::rest.png[canvas,size=contain]

Make it a bootiful Webapplication

=== Spring Data JDBC specific

Almost nothing.

Entities need to be Beans for JSON serializer.

== (Maybe) upcoming

image::future.png[canvas,size=contain]

Not promising anything.

=== Better CRUD

upserts?

=== Derived Queries

=== Sorting and Paging

=== Named Queries with MyBatis

=== Named Queries via Properties

=== Spring Boot Support

Outdated PoC: https://github.com/schauder/spring-data-jdbc-boot-starter

== Is there reactive support?

=== The problem

=== JDBC is blocking

Could be wrapped in a `ThreadPool` which would be a compromise.

=== JPA won't happen

The whole approach is opposite to reactive.

=== ADBA

*A*synchronous *D*ata*B*ase *A*pi being developed by Oracle

Java One Slides: https://events.rainfocus.com/catalog/oracle/oow17/catalogjavaone17?search=CON1491&showEnrolled=false

Mailing List: http://mail.openjdk.java.net/mailman/listinfo/jdbc-spec-discuss

Repository: http://hg.openjdk.java.net/jdk/sandbox/file/JDK-8188051-branch/src/jdk.incubator.adba/share/classes

Manually maintained mirror on github: https://github.com/pull-vert/adba-mirror

[NOTE.speaker]
====

No visible feedback from other database vendors.

Pushed back against reactive at first.
Now it seems they changed their minds.

Everybody is curious, I guess.
====

=== AoJ

**A**DBA **o**ver **J**DBC

An rudimentary implementation of ADBA based on JDBC.

https://github.com/oracle/oracle-db-examples/tree/master/java/AoJ

=== R2DBC

**R**eactive **R**elational **D**atabase **C**onnectivity

Github Orga: https://github.com/r2dbc

=== R2DBC Contributers

 * Pivotal (Spring, Spring Data, Reactor)
 * jOOQ (Lukas Eder)
 * RxJava (DÃ¡vid Karnok)

=== R2DBC Experimental Implementations

Postgres https://github.com/r2dbc/r2dbc-postgresql

Planned: R2DBC over ADBA

=== R2DBC @ Spring Data

Database Client inspired by Webclient.

Reactive Relational Repositories.

Happy Paths in https://github.com/spring-projects/spring-data-jdbc/tree/r2dbc

=== Reactive Wrap up

Lot's is happening.

Many parties involved.

Nothing that is production ready in the near future.

== References

* Github: https://github.com/spring-projects/spring-data-jdbc

* Project: https://projects.spring.io/spring-data-jdbc/

* Examples: https://github.com/spring-projects/spring-data-examples/tree/master/jdbc

* Slides on Github: https://github.com/schauder/talk-spring-data-jdbc

* Freeletics: https://www.freeletics.com

include::self.ad[leveloffset=1]
